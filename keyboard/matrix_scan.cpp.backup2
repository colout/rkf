#include <stdio.h>
#include <string.h>

#include "pico/stdlib.h"
#include "hardware/gpio.h"

#include "helpers.h"
#include "config.h"

static const uint read_pins[] = MATRIX_ROW_PINS ;
static const uint write_pins[] = MATRIX_COL_PINS ;
static const uint read_num = MATRIX_ROWS;
static const uint write_num = MATRIX_COLS;

// scan_interval is interval for each row scanning of matrix (us).
static const uint32_t scan_interval = 200000;
// debounce is inhibition interval for changing status of each keys.
static const uint16_t debounce = 5;

static uint32_t write_scanmask;
static uint32_t write_scanval[write_num];
static uint32_t read_masks[read_num];

typedef struct {
    bool on;
    uint8_t last;
} scan_state;

static scan_state matrix_states[read_num * write_num];

#if 0
static void matrix_changed(uint nread, uint nwrite, bool on, uint8_t when) {
    //printf("matrix_changed: read=%d write=%d %s when=%d\n", nread, nwrite, on ? "ON" : "OFF", when);
    uint8_t code = layer_getcode(nread, nwrite, on);
    if (code != 0) {
        hidkb_report_code(code, on);
    }
}

static void matrix_suppressed(uint nread, uint nwrite, bool on, uint8_t when, uint8_t last, uint8_t elapsed) {
    //printf("matrix_suppressed: read=%d write=%d %s when=%d last=%d elapsed=%d\n", nread, nwrite, on ? "ON" : "OFF", when, last, elapsed);
}
#endif

__attribute__((weak)) void matrix_changed(uint nread, uint nwrite, bool on, uint8_t when) {
    printf("matrix_changed: read=%d write=%d %s when=%d\n", nread, nwrite, on ? "ON" : "OFF", when);
}

__attribute__((weak)) void matrix_suppressed(uint nread, uint nwrite, bool on, uint8_t when, uint8_t last, uint8_t elapsed) {
    printf("matrix_suppressed: read=%d write=%d %s when=%d last=%d elapsed=%d\n", nread, nwrite, on ? "ON" : "OFF", when, last, elapsed);
}

// matrix_task scan whole switch matrix.
void matrixScan() {
    static uint8_t count = 0;
    uint x = 0;
    for (uint nwrite = 0; nwrite < write_num; nwrite++) {
        gpio_put_masked(write_scanmask, write_scanval[nwrite]);
        sleep_us(scan_interval);
        uint32_t bits = gpio_get_all();

        // Logging stuff

        // Only log for last pin on column (write): B6 / 9 (5 in array)
        if (nwrite == 5) {
            printf("Column 9/D5 (last column):\n");
            printf("* Pin location:   00000000000000000000010000000000\n");
            printf("* Write Scanmask: ");
            printBits(sizeof(write_scanmask), &write_scanmask);
            printf("\n");
            printf("* Write Scanval:  ");
            printBits(sizeof(write_scanval[nwrite]), &write_scanval[nwrite]);
            printf("\n");
            printf("* Bits:           ");
            printBits(sizeof(bits), &bits);
            printf("\n");
            printf("* GPIO dir (1==out): ");
            serialLog(gpio_get_dir(write_pins[nwrite]));
            printf("\n");
            printf("GPIO Function: ");
            serialLog(gpio_get_function(write_pins[nwrite]));
            printf("\n");
            printf("Get out level: ");
            serialLog(gpio_get_out_level(write_pins[nwrite]));
            printf("\n");
            printf("\n");
        }        
        // End logging stuff


        for (uint nread = 0; nread < read_num; nread++) {
            bool on = (bits & read_masks[nread]) == 0;
            if (on != matrix_states[x].on) {
                uint8_t elapsed = count - matrix_states[x].last;
                if (elapsed >= debounce) {
                    matrix_states[x].on = on;
                    matrix_states[x].last = count;
                    matrix_changed(nread, nwrite, on, count);
                } else {
                    matrix_suppressed(nread, nwrite, on, count, matrix_states[x].last, elapsed);
                }
            }
            x++;
        }
    }
    count++;
}

void matrixInit() {
    printf("matrix_init: sizeof(matrix_states)=%d\n", sizeof(matrix_states));
    // setup pins for read.
    for (int i = 0; i < read_num; i++) {
        uint io = read_pins[i];
        gpio_init(io);
        gpio_set_dir(io, GPIO_IN);
        gpio_pull_up(io);
        read_masks[i] = 1ul << io;
    }
    // setup pins for write.
    uint32_t mask = 0;
    for (int i = 0; i < write_num; i++) {
        uint io = write_pins[i];
        gpio_init(io);
        gpio_set_dir(io, GPIO_OUT);
        write_scanval[i] = ~(1ul << io);
        mask |= 1ul << io;
    }
    // compose scan mask.
    write_scanmask = mask;
    for (int i = 0; i < write_num; i++) {
        write_scanval[i] &= mask;
    }
    memset(matrix_states, 0, sizeof(matrix_states));
}